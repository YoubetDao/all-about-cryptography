# 消息认证码（MAC）概述

## 引言
在本模块中，我们将不再讨论加密，而是转向消息完整性的讨论。我们的目标是在不考虑保密性的情况下提供完整性。

## 现实应用场景

在现实世界中，有许多只需要完整性而不需要保密性的应用场景：

1. **操作系统文件**
   - Windows系统文件本身并不保密
   - 但需要防止被病毒或恶意软件修改

2. **网页广告**
   - 广告商不在意广告内容被复制
   - 但需要防止广告内容被篡改

如何保证消息的完整性？使用MAC（message authentication code）。

## MAC的基本机制

### 工作原理
1. Alice和Bob共享一个密钥K（对攻击者保密）
2. Alice要发送公开消息M给Bob
3. Alice使用MAC签名算法S(K,M)生成短标签（约90-100位）
4. Alice将消息和标签一起发送给Bob
5. Bob使用MAC验证算法验证消息完整性

### MAC的定义
MAC由两个算法组成：
- **签名算法**：S(k,m) → t ∈ T，其中t是标签空间T中的标签
- **验证算法**：V(k,m,t) → {yes,no}，验证消息-标签对的有效性

### 一致性要求
对于密钥空间中的每个K和消息空间中的每个消息：
- 用同一密钥进行签名和验证应得到"是"的回应

## 为什么需要共享密钥

### CRC的反面教材
- CRC（循环冗余校验）是无密钥的校验和算法
- 设计用于检测随机错误，而非恶意修改
- 攻击者可以：
  1. 拦截Alice的消息和标签
  2. 生成新消息M'
  3. 计算新的CRC
  4. 发送给Bob
- Bob收到后会验证tag == CRC(M')，由于CRC是公开的算法，攻击者生成的新CRC可以通过验证，会认为来自Alice

### 密钥的重要性
- 没有密钥，Bob无法区分Alice和攻击者
- 密钥使Alice可以执行攻击者无法完成的操作，计算出攻击者无法修改的标签 
- CRC只适用于随机错误检测，不适用于防御恶意攻击

## MAC的安全性定义

### 攻击者能力：选择消息攻击(chosen message attack)
- 可以选择消息m1到mq给Alice
- Alice计算这些消息的标签
- 攻击者获得标签

### 现实世界的选择消息攻击示例
- 攻击者发送电子邮件给Alice
- Alice为邮件计算标签并存储
- 攻击者获取存储介质，得到标签

### 攻击者目标：存在性伪造(existential forgery)
- 产生新的有效消息-标签对
- 必须与选择消息攻击期间获得的对不同
- 即使是无意义消息的伪造也视为不安全

### 安全性的额外要求
- 攻击者不能为已知消息生成新标签
- 对于加密和完整性的组合很重要

## MAC的安全性游戏

### 游戏流程
MAC I=(S,V)安全性游戏包含以下步骤:
1. 挑战者(Chal.)随机选择MAC密钥 k ← K
2. 攻击者(Adv.)进行选择消息攻击（Q次）:
   - 攻击者选择消息 m1,...,mq ∈ M
   - 获得标签 ti ← S(k,mi)
3. 攻击者尝试存在性伪造,输出一个消息-标签对 (m,t)

### 胜利条件
攻击者输出的消息-标签对(m,t)必须满足:
1. V(k,m,t) = 'yes'  能通过验证
2. m ∉ {m1,...,mq}   与之前未见过

### 安全性定义
- 攻击者优势: Adv[A,I] = Pr[b=1]
  其中 b = 1 当且仅当:
  - V(k,m,t) = 'yes' 且 
  - (m,t) ∉ {(m1,t1),...,(mq,tq)}
  否则 b = 0
- 安全MAC: 对于所有有效攻击者A,Adv[MAC][A] ≤ ε(可忽略值)

## 重要安全考虑

### 标签碰撞问题
- 如果两个消息有相同标签的概率为1/2，则MAC不安全
- 攻击者可通过选择消息攻击利用这一点

### 标签长度问题
- 过短的标签（如5位）使MAC不安全
- 攻击者可以通过随机猜测成功
- 推荐标签长度：64位、96位或128位

## 实际应用：使用MAC保护系统文件

### 实现方式
1. 安装操作系统时：
   - 用户提供密码
   - 从密码中获取密钥K
   - 为每个系统文件计算标签
   - 存储文件和标签
   - 擦除密钥K

2. 验证时：
   - 从干净环境启动
   - 用户重新提供密码
   - 验证所有文件的MAC

### 注意事项
- 病毒无法创建带有效标签的新文件
- 需要将文件名包含在MAC计算中，防止文件交换攻击

# 构建安全的MAC

## MAC的基本概念回顾
- MAC是一对算法:
  - 签名算法:接收消息和密钥作为输入，生成标签
  - 验证算法:接收密钥、消息和标签作为输入，输出0或1
- 安全性要求:在选择消息攻击下存在性不可伪造
  - 攻击者可以进行选择消息攻击
  - 无法创建有效的新消息-标签对

## 基于PRF构建MAC

### 基本构造方法
1. 使用PRF(伪随机函数)作为基础
2. 签名过程:对消息M计算PRF(M)作为标签
3. 验证过程:重新计算PRF(M)并与标签比对

### 不安全的例子
- 使用10位输出的PRF，构造MAC
- 问题:标签太短
- 攻击者有1/2^10的概率猜对MAC
- 1/1024的成功率是不可忽略的

### 安全性定理
- 如果PRF输出足够长，可以构建安全的MAC
- 安全要求:
  - PRF必须是安全的
  - 输出空间要足够大(如80位)
  - 攻击者优势最多为1/2^80

## 安全性证明分析

### 基于真随机函数的分析
1. 考虑使用真随机函数而非PRF
2. 攻击者获取多个消息的标签
3. 对新消息M预测标签的成功率仅为1/Y (Y是输出空间大小)
4. 因为函数在新点的值与已知点完全独立，攻击者只能猜测标签值

### PRF的等效性
- 攻击者无法区分PRF的行为与真随机函数
- 攻击者在PRF上的优势同样被限制在1/Y

## 实际应用扩展

### 从小MAC到大MAC
- AES作为基础PRF(16字节，128位输入)
- 两种构造方法:
  1. CBC-MAC:银行业常用(如自动清算所ACH系统，确保支票在银行间传输完整性)
  2. HMAC:互联网协议常用(SSL/IPsec/SSH)
- 从接收小消息的PRF开始，产生可处理GB级长消息的PRF，都可以用AES作为底层密码来实现。

### MAC输出截断
- N位PRF可安全截断至T位(T<N)
- 截断后仍保持安全性
- 实践建议:
  - 不应截断至过短(如3位)
  - 80位或64位是合理的选择
  - 无需保持完整的128位输出
